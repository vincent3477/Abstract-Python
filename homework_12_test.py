# -*- coding: utf-8 -*-
"""Homework_12_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R44PYRjbghxGcjiaTMRyINzPb5i_FpjQ

Before you turn this problem in, make sure everything runs as expected. First, **restart the kernel** (in the menubar, select Kernel$\rightarrow$Restart) and then **run all cells** (in the menubar, select Cell$\rightarrow$Run All).

Make sure you fill in any place that says `YOUR CODE HERE` or "YOUR ANSWER HERE", as well as your name and collaborators below:
"""

NAME = "Vincent Siu"
COLLABORATORS = ""

"""---

# CSE 30 Winter 2022 - Homework 12

## Graphs


### Instructions

Please disregard the YOUR NAME and COLLABORATORS above.  They are put there atomatically by the grading tool.
You can find instructions on how to work on a homework on Canvas.  Here is a short summary:

### Submitting your work

To submit your work:

* First, click on "Runtime > Restart and run all", and check that you get no errors.  This enables you to catch any error you might have introduced, and not noticed, due to your running cells out of order.
* Second, download the notebook in .ipynb format (File > Download .ipynb) and upload the .ipynb file to [this form](https://docs.google.com/forms/d/e/1FAIpQLSeJ5mAlZ0-3xJ75wY4TddUeD54NZvMIm7SgfHR00n7AxtO9mw/viewform?usp=sf_link). **This homework is due at 11:59pm on Tuesday, 22 February 2022.**.

You can submit multiple times; the last submission before the deadline is the one that counts.

### Homework format

For each question in this notebook, there is:

* A text description of the problem.
* One or more places where you have to insert your solution.  You need to complete every place marked:

    `# YOUR CODE HERE`
    
    and you should not modify any other place.
* One or more test cells.  Each cell is worth some number of points, marked at the top.  You should not modify these tests cells.  The tests pass if no error is printed out: when there is a statement that says, for instance:

    `assert x == 2`
    
    then the test passes if `x` has value 2, and fails otherwise.  You can insert a `print(x)` (for this case!) somewhere if you want to debug your work; it is up to you.  
    
### Notes:

* Your code will be tested both according to the tests you can see (the `assert` statements you can see), _and_ additional tests.  This prevents you from hard-coding the answer to the particular questions posed.  Your code should solve the _general_ intended case, not hard-code the particular answer for the values used in the tests.

* **Please do not delete or add cells!** The test is autograded, and if you modify the test by adding or deleting cells, even if you re-add cells you delete, you may not receive credit.

* **Please do not import modules that are not part of the [standard library](https://docs.python.org/3/library/index.html).** You do not need any, and they will likely not available in the grading environment, leading your code to fail.

* **If you are inactive too long, your notebook might get disconnected from the back-end.** Your work is never lost, but you have to re-run all the cells before you continue.

* You can write out print statements in your code, to help you test/debug it. But remember: the code is graded on the basis of what it outputs or returns, not on the basis of what it prints.

* **TAs and tutors have access to this notebook,** so if you let them know you need their help, they can look at your work and give you advice.

### Grading

Each cell where there are tests is worth a certain number of points.  You get the points allocated to a cell only if you pass _all_ the tests in the cell.

The tests in a cell include both the tests you can see, and other, similar, tests that are used for grading only.  Therefore, you cannot hard-code the solutions: you really have to solve the essence of the problem, to receive the points in a cell.

### Code of Conduct

* Work on the test yourself, alone.
* You can search documentation on the web, on sites such as the Python documentation sites, Stackoverflow, and similar, and you can use the results.
* You cannot share your work with others or solicit their help.

A (directed) graph $G = (V, E)$ consists of a set of vertices (or nodes) $V$, and a set of edges $E \subseteq V \times V$.

![graph1.png](data:image/png;base64,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)

An example of a graph with $V = \{a, b, c, d, e, f, g\}$ and $E = \{(a, b), (a, c), (a,d), (b,d), (c,a), (c, e), (d, b), (d, c), (f, g), (g, f)\}$.

How should we represent a graph?  A general principle of software development -- really, of life -- is: failing special reasons, always go for the simplest solution.
So our first attempt consists in storing a graph exactly according to its definition: as a set of vertices and a set of edges.
"""

class Graph(object):

    def __init__(self, vertices=None, edges=None):
        # We use set below, just in case somebody passes a list to the initializer.
        self.vertices = set(vertices or [])
        self.edges = set(edges or [])

g = Graph(vertices={'a', 'b', 'c', 'd', 'e', 'f', 'g'},
          edges={('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'd'),
                 ('c', 'a'), ('c', 'e'), ('d', 'b'), ('d', 'c'),
                 ('f', 'g'), ('g', 'f')})

"""Great, but, how do we display graphs?  And what can we do with them?  

Let's first of all add a method .show() that will enable us to look at a graph; this uses the library [networkx](https://networkx.github.io/).
"""

import networkx as nx # Library for displaying graphs.

class Graph(object):

    def __init__(self, vertices=None, edges=None):
        # We use set below, just in case somebody passes a list to the initializer.
        self.vertices = set(vertices or [])
        self.edges = set(edges or [])

    def show(self):
        g = nx.DiGraph()
        g.add_nodes_from(self.vertices)
        g.add_edges_from(self.edges)
        nx.draw(g, with_labels=True)

g = Graph(vertices={'a', 'b', 'c', 'd', 'e', 'f', 'g'},
          edges={('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'd'),
                 ('c', 'a'), ('c', 'e'), ('d', 'b'), ('d', 'c'),
                 ('f', 'g'), ('g', 'f')})
g.show()

"""Ok, this is not nearly as pretty as what we generated by hand, but it will have to do.

## One-Step Reachability and Graph Representations

What are conceivable operations on graphs?  There are some basic ones, such as adding a vertex and adding an edge.  These are easily taken care of.
"""

import networkx as nx # Library for displaying graphs.

class Graph(object):

    def __init__(self, vertices=None, edges=None):
        # We use set below, just in case somebody passes a list to the initializer.
        self.vertices = set(vertices or [])
        self.edges = set(edges or [])

    def show(self):
        g = nx.DiGraph()
        g.add_nodes_from(self.vertices)
        g.add_edges_from(self.edges)
        nx.draw(g, with_labels=True)

    def add_vertex(self, v):
        self.vertices.add(v)

    def add_edge(self, e):
        self.edges.add(e)

"""Further, a graph represents a set of connections between vertices, so a very elementary question to ask is the following: if we are at vertex $v$, can we get to another vertex $u$ by following one or more edges?

As a first step towards the solution, we want to compute the set of vertices reachable from $v$ in one step, by following one edge; we call these vertices the _successors_ of $v$.

Writing a function g.successors(u) that returns the set of successors of $u$ is simple enough.  Note that the code directly mimicks the mathematical definition:

$$
\mathit{Successors}(u) = \{v \in V \mid (u, v) \in E\} \; .
$$
"""

import networkx as nx # Library for displaying graphs.

class Graph(object):

    def __init__(self, vertices=None, edges=None):
        # We use set below, just in case somebody passes a list to the initializer.
        self.vertices = set(vertices or [])
        self.edges = set(edges or [])

    def show(self):
        g = nx.DiGraph()
        g.add_nodes_from(self.vertices)
        g.add_edges_from(self.edges)
        nx.draw(g, with_labels=True)

    def add_vertex(self, v):
        self.vertices.add(v)

    def add_edge(self, e):
        self.edges.add(e)

    def successors(self, u):
        """Returns the set of successors of vertex u"""
        return {v for v in self.vertices if (u, v) in self.edges}

g = Graph(vertices={'a', 'b', 'c', 'd', 'e', 'f', 'g'},
          edges={('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'd'),
                 ('c', 'a'), ('c', 'e'), ('d', 'b'), ('d', 'c'),
                 ('f', 'g'), ('g', 'f')})
g.successors('a')

"""But there's a rub.  The method successors, as written, requires us to loop over the whole set of vertices.  Because self.edges is a set, represented as a hash table, once we have a pair (u, v), checking

    (v, u) in self.edges
    
is efficient.  But typically, graphs have a locality structure, so that each node is connected only to a small subset of the total vertices; having to loop over all vertices to find the successors of a vertex is a great waste.
It is as if I asked you to what places you can get from San Francisco with a direct flight, and to answer, you started to rattle off all of the world's cities, from Aachen, Aalborg, Aarhus, ..., all the way to ZÃ¼rich, Zuwarah, Zwolle, and for each city you checked if there's a flight from San Francisco to that city!  Clearly not the best method.

Given that our main use for graphs is to answer reachability-type questions, a better idea is to store the edges via a dictionary that associates with each vertex the set of successors of the vertex.  The vertices will simply be the keys of the dictionary.

"""

import networkx as nx # Library for displaying graphs.

class Graph(object):

    def __init__(self, vertices=None, edges=None):
        self.s = {u: set() for u in vertices or []}
        for u, v in (edges or []):
            self.add_edge((u, v))

    def show(self):
        g = nx.DiGraph()
        g.add_nodes_from(self.s.keys())
        g.add_edges_from([(u, v) for u in self.s for v in self.s[u]])
        nx.draw(g, with_labels=True)

    def add_vertex(self, v):
        if v not in self.s:
            self.s[v] = set()

    def add_edge(self, e):
        u, v = e
        self.add_vertex(u)
        self.add_vertex(v)
        self.s[u].add(v)

    @property
    def vertices(self):
        return set(self.s.keys())

    def successors(self, u):
        """Returns the set of successors of vertex u"""
        return self.s[u]

g = Graph(vertices={'a', 'b', 'c', 'd', 'e', 'f', 'g'},
          edges={('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'd'),
                 ('c', 'a'), ('c', 'e'), ('d', 'b'), ('d', 'c'),
                 ('f', 'g'), ('g', 'f')})
g.show()
print(g.successors('a'))

"""## Graph Reachability

We now come to one of the fundamental graph algorithms, in fact, perhaps _the_ most fundamental algorithm for graphs: computing the set of vertices reachable from a given starting vertex.  Exploring what is reachable from a graph vertex is a truly basic task, and variations on the algorithm can be used to answer related questions, such as whether a vertex is reachable from a given starting vertex.

The algorithm keeps two sets of vertices:

* The set of _open_ vertices: these are the vertices that are known to be reachable, and whose successors have not yet been explored.
* The set of _closed_ vertices: these are the vertices that are known to be reachable, and whose successors we have already explored.

Intially, the set of open vertices contains only the starting vertex, and the set of closed vertices is empty, as we have completed no exploration.
Repeatedly, we pick an open vertex, we move it to the closed set, and we put all its successor vertices -- except those that are closed already -- in the open set.   The algorithm continues until there are no more open vertices; at that point, the set of reachable vertices is equal to the closed vertices.  

If there is _one_ graph algorithm that you must learn by heart, and that you should be able to write even when you hang upside down from monkeybars, this is it.

Let us write the algorithm as a function first.
"""

def reachable(g, v):
    """Given a graph g, and a starting vertex v, returns the set of states
    reachable from v in g."""
    vopen = {v}
    vclosed = set()
    while len(vopen) > 0:
        u = vopen.pop()
        vclosed.add(u)
        vopen.update(g.successors(u) - vclosed)
    return vclosed

print(reachable(g, 'a'))
print(reachable(g, 'g'))

"""To visualize the algorithm, let us write a version where at each iteration, open vertices are drawn in red and closed ones in green"""

def reachable(g, v):
    """Given a graph g, and a starting vertex v, returns the set of states
    reachable from v in g."""
    vopen = {v}
    vclosed = set()
    while len(vopen) > 0:
        u = vopen.pop()
        vclosed.add(u)
        vopen.update(g.successors(u) - vclosed)
    return vclosed

reachable(g, 'a')

"""## Breadth-First and Depth-First Search

### Breadth First

In **breadth-first** search, we explore in concentric circles emanating from the starting point: first all vertices at distance 1, then all vertices at distance 2, and so on.  In general, we explore all vertices at distance $\leq n$ before we explore vertices at distances $>n$.

To implement breadth-first search, we store the open vertices `vopen` as a list rather than a set.  We then explore vertices in the order they have been added to `vopen`: this ensures that vertices closer to the search origin are explored earlier than farther-away vertices.

The difference in code between reachability search, and its specialized breadth-first version, is minimal.

"""

def breath_first(g, v):
    """Given a graph g, and a starting vertex v, returns the set of states
    reachable from v in g."""
    # vopen is a FIFO: first in, first out. Like a normal queue.
    # we add elements from the end, and pop them from the beginning.
    vopen = [v]
    vclosed = set()
    while len(vopen) > 0:
        u = vopen.pop(0) # Pop from the beginning
        vclosed.add(u)
        # vopen.update(g.successors(u) - vclosed)
        for w in g.successors(u) - vclosed:
            if w not in vopen:
                vopen.append(w) # Add to the end
    return vclosed

gg = Graph(vertices={},
           edges={('a', 'b'), ('b', 'c'), ('c', 'd'),
                  ('a', 'u'), ('u', 'v'), ('v', 'w'), ('u', 'z')})

breath_first(gg, 'a')

"""We see that we explore $b$ and $u$ before any of their successors are explored, and similarly, we explore $z$, $v$, and $c$ before $d$ or $w$.

### Depth-First Search

In **depth-first** search, we follow a path as long as possible, and only when we come to an end do we explore other nodes.  In depth-first search, the most recent visited vertex, the one added last to the list of open vertices, is the one that will be explored first.

The difference in code from breadth-first search is minimal.  In breadth-first search, the vertex to be explored next is the _oldest_ among the open ones:

        u = vopen.pop(0)

In depth-first search, it will be the _newest_ among the open ones:

        u = vopen.pop()

That's the whole difference.
"""

def depth_first(g, v):
    """Given a graph g, and a starting vertex v, returns the set of states
    reachable from v in g."""
    # vopen is a stack / LIFO: last in, first out. Like a stack.
    # we add elements from the end, and pop them from the end.
    vopen = [v]
    vclosed = set()
    while len(vopen) > 0:
        u = vopen.pop() # THIS is the difference: there is no 0 in the parentheses.
        vclosed.add(u)
        # vopen.update(g.successors(u) - vclosed)
        for w in g.successors(u) - vclosed:
            if w not in vopen:
                vopen.append(w)
    return vclosed

depth_first(gg, 'a')

"""We see how in depth-first search we explore completely one side of the successors of $a$, consisting of $u, v, w, z$, before exploring the other side $b, c, d$.

## Problem 1: Returning the edges

In our latest implementation, we do not have direct access to the edges of the graph.  In other words, for a graph g, we cannot do:

    for (u, v) in g.edges:
        ...

We ask you to write an iterator over edges, to make the above code work.  The iterator should yield the edges of the graph, one by one.
"""

### An iterator for the set of edges

def graph_edges(self):
    """Yields the edges of the graph, one by one.  Each edge is yielded as a
    pair of vertices (source, destination). """
    # YOUR CODE HERE
    for i in self.s:
      for j in self.s.get(i):
        yield i, j


Graph.edges = property(graph_edges)

### Here you can play with your code.
e = [(1, 2), (1, 3), (2, 3)]
g = Graph(vertices=[1, 2, 3], edges=e)
g.edges

"""Here are some tests."""

### 10 points: simple tests

e = [(1, 2), (1, 3), (2, 3)]
g = Graph(vertices=[1, 2, 3], edges=e)
assert set(g.edges) == set(e)

import types
# You need to build a generator, one of those things with the yield statement.
assert isinstance(g.edges, types.GeneratorType)

"""Here are some randomized test."""

### 10 points: random tests

import random

for _ in range(10):
    num_vertices = random.randint(4, 10)
    num_edges = random.randint(1, num_vertices * num_vertices)
    vertices = random.sample(range(0, 1000), num_vertices)
    edges = {(random.choice(vertices), random.choice(vertices)) for _ in range(num_edges)}
    g = Graph(vertices=vertices, edges=edges)
    assert set(g.edges) == edges

"""## Problem 2: Is a graph a tree?

A tree is a graph $(V, E)$ with two special properties:

* Every vertex has at most one incoming edge.
* Either there are no vertices, or there is a vertex with no incoming edges, called the _root_, from which all other vertices are reachable.

If the second property does not hold, incidentally, the graph is called a _forest._

Write an `is_tree` function such that `is_tree(g)` returns True if the graph `g` is a tree, False otherwise.
"""

### Implementation of tree test

def is_tree(g):
    """Returns True iff the graph is a tree."""
    # YOUR CODE HERE
    if vertices == set():
      return True

    edgeReference = dict()
    for i in g.vertices:
      edgeReference[i] = 0
    for j in g.vertices:
      for k in g.edges:
        if j == k[1]:
          edgeReference[j] +=1
    print(edgeReference)
    zeroCount = 0 #should be only one zero, where only one object has zero references. The one that has zero references would be the root.
    for l in edgeReference:
      if edgeReference[l] > 1:
        return False
      if edgeReference[l] == 0:
        zeroCount += 1
      if zeroCount > 1 or zeroCount == 0:
        return False
    return True

### Here you can play with your code
assert not is_tree(Graph(vertices = [1,2,3,4], edges =[(1,2),(3,4)]))
assert not is_tree(Graph(vertices = [1,2], edges =[(1,2),(2,1)]))

### 10 points: Tests for `is_tree`

g = Graph(vertices=[1, 2, 3], edges=[(1, 2), (1, 3)])
assert is_tree(g)
g = Graph(vertices=[1, 2, 3], edges=[(1, 2), (2, 3), (1, 3)])
assert not is_tree(g)
g = Graph(vertices=[1, 2, 3], edges=[(1, 3), (2, 3)])
assert not is_tree(g)
g = Graph(vertices=[1, 2, 3], edges=[(1, 3), (2, 3)])
assert not is_tree(g)
g = Graph(vertices=[1, 2, 3,5,6,7,8,9,10], edges=[(1, 3), (2, 3)])

### 10 points: More tests for `is_tree`

g = Graph()
assert is_tree(g)

"""## Problem 3: Reachability using either of two graphs

In this problem, you are given _two_ graphs `g1`, `g2`, that share the same set of vertices.
You have to write a function `can_reach(v, g1, g2, w)`, which returns `True` iff you can go from vertex `v` to vertex `w` using either edges of `g1` or `g2`.
Note that to go from `v` to `w`, you can use one or more edges from `g1` and one or more edges of `g2`, mixed in any way you like.  To solve the problem, you have to modify the reachability algorithms so that edges from either graph can be used.

_Hint:_ Modify the reachability algorithm.

"""

def can_reach(v, g1, g2, w):
    """Given two graphs g1, g2 that share the same vertices, and two verteces v, w,
    returns True if you can go from v to w using edges of either g1 or g2 (mixed any
    way you want) and False otherwise."""
    # YOUR CODE HERE
    g1edge = set(g1.edges)
    g2edge = set(g2.edges)
    g3edge = Graph(vertices=vertices, edges= g1edge | g2edge)
    closedV = set()
    openV = {v}
    while len(openV) > 0:
      u = openV.pop()
      closedV.add(u)
      openV.update(g3edge.successors(u)-closedV)
    if w in closedV:
      return True
    return False

### Here you can play with your code.
g1 = Graph(vertices=vertices, edges=[(n, 2 * n) for n in range(100) if 2 * n < 100])
g2 = Graph(vertices=vertices, edges=[(n, 3 * n) for n in range(100) if 3 * n < 100])
assert can_reach(1, g1, g2, 24)

### 10 points: simple tests for can_reach

vertices = {1, 2, 3, 4, 5, 6, 7}
g1 = Graph(vertices=vertices, edges=[(1, 2), (3, 4)])
g2 = Graph(vertices=vertices, edges=[(2, 3), (4, 5), (6, 7)])
assert can_reach(1, g1, g2, 2)
assert can_reach(1, g1, g2, 3)
assert can_reach(1, g1, g2, 4)
assert can_reach(1, g1, g2, 5)
assert not can_reach(1, g1, g2, 6)
assert not can_reach(1, g1, g2, 7)

### 10 points: more advanced tests for can_reach

vertices = set(range(100))
# g1 edges go from n to 2n, g2 edges go from n to 3n.
g1 = Graph(vertices=vertices, edges=[(n, 2 * n) for n in range(100) if 2 * n < 100])
g2 = Graph(vertices=vertices, edges=[(n, 3 * n) for n in range(100) if 3 * n < 100])
#assert can_reach(1, g1, g2, 6)
assert can_reach(1, g1, g2, 24)
assert can_reach(1, g1, g2, 32)
assert can_reach(1, g1, g2, 9)
assert not can_reach(1, g1, g2, 15)
assert not can_reach(1, g1, g2, 60)
assert can_reach(5, g1, g2, 15)
assert can_reach(5, g1, g2, 30)

